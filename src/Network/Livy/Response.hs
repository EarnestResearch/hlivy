{-# LANGUAGE FlexibleContexts #-}

module Network.Livy.Response
  ( -- * Receiving a response
    send
  ) where

import           Control.Lens
import           Control.Monad.Catch
import           Control.Monad.Reader
import           Data.Aeson
import qualified Data.ByteString as S
import qualified Data.ByteString.Char8 as C
import qualified Data.ByteString.Lazy as LBS
import           Network.HTTP.Client
import           Network.HTTP.Types

import           Network.Livy.Env
import           Network.Livy.Monad
import           Network.Livy.Request
import           Network.Livy.Types


-- | Send a request, returning the associated response if successful.
send :: LivyConstraint r m a => a -> m (Either LivyError (LivyResponse a))
send req = do
  env <- reader $ view environment
  catch (handleRequest req env) handleHttpException


-- | Send the request to Livy.
handleRequest
  :: (MonadIO m, LivyRequest b, FromJSON a)
  => b -- ^ The 'LivyRequest'.
  -> Env -- ^ An 'Env' to perform the request with.
  -> m (Either LivyError a)
handleRequest req env = liftIO $ httpLbs req' man >>= handleResponse
  where
    man = env ^. envManager
    req' = request req & setHost (env ^. envHost) & setPort (env ^. envPort)


-- | Interpret the response.
handleResponse
  :: (Applicative m, FromJSON a)
  => Response LBS.ByteString -- ^ Livy response.
  -> m (Either LivyError a)
handleResponse resp =
  if livyHttpError (responseStatus resp) then pure . Left $
    makeLivyHttpError (sCode resp) (sMessage resp) (responseBody resp)
  else pure $ parseResponse resp
  where
    sCode = statusCode . responseStatus
    sMessage = statusMessage . responseStatus


-- | Parse the Livy response into a 'LivyResponse', if possible.
parseResponse :: FromJSON a => Response LBS.ByteString -> Either LivyError a
parseResponse resp = case eitherDecode' (responseBody resp) of
  Left e  -> Left $ LivyError ParseFailure (C.pack e) Nothing Nothing
  Right v -> Right v


-- | Handle exceptions thrown by the underlying http-client library.
handleHttpException
  :: Applicative m
  => HttpException -- ^ Exception generated by http-client.
  -> m (Either LivyError a)
handleHttpException (InvalidUrlException url msg) = pure . Left $
  LivyError InvalidRequest (C.pack $ url <> ": " <>  msg) Nothing Nothing
handleHttpException (HttpExceptionRequest req content) =
  case content of
    StatusCodeException r _ -> pure . Left $
      LivyError InvalidRequest (sMessage r) Nothing Nothing
    ConnectionFailure _     -> pure . Left $
      LivyError ConnectionError (errMsg "Connection error") Nothing Nothing
    ConnectionTimeout       -> pure . Left $
      LivyError ConnectionError (errMsg "Connection timeout") Nothing Nothing
    ConnectionClosed        -> pure . Left $
      LivyError ConnectionError (errMsg "Connection closed") Nothing Nothing
    _                       -> pure . Left $
      LivyError UnknownErrorType (errMsg "Unknown error type") Nothing Nothing
  where errMsg s = C.pack $ show req <> ": " <> s
        sMessage = statusMessage . responseStatus


-- | Whether there was an error resulting from the request.
livyHttpError :: Status -> Bool
livyHttpError s = statusCode s >= 400


-- | Create a 'LivyError' value for an HTTP error returned from Livy.
makeLivyHttpError
  :: Int -- ^ The HTTP status code.
  -> S.ByteString -- ^ Status message.
  -> LBS.ByteString -- ^ Response body.
  -> LivyError
makeLivyHttpError c m b = LivyError InvalidRequest m (Just b) $
  case c of
    400 -> Just BadRequest
    401 -> Just Unauthorized
    402 -> Just RequestFailed
    403 -> Just Forbidden
    404 -> Just NotFound
    405 -> Just BadMethod
    500 -> Just ServerError
    501 -> Just ServerError
    502 -> Just ServerError
    503 -> Just ServerError
    504 -> Just ServerError
    _   -> Just UnknownHTTPErrorCode
